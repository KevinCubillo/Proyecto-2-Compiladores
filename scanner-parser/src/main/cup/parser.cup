package com.compiladores;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


parser code  {:

    //Connect to the lexer
    Lexer lexer;
    public Boolean errorDisplayed = false;
    Map<String, ArrayList<String[]>> tablasDeSimbolos = new HashMap<>();
    String currentHash = "";
    List<String> intermediateCode = new ArrayList<>();
    int currentTemp = 1;


    @SuppressWarnings("deprecation")
    public parser(Lexer lexer) {
        this.lexer = lexer;
        this.symbolFactory = new DefaultSymbolFactory();

        //Inicializar tabla de simbolos Global
        currentHash = "Global";
        ArrayList<String[]> tabla = new ArrayList<>();
        String[] titulo = new String[1];
        titulo[0] = "Variables Globales";
        tabla.add(titulo);
        tablasDeSimbolos.put(currentHash, tabla);

    }

//Metodo para imprimir la tabla de simbolos
public void imprimirTablaSimbolos() {
    System.out.println("\n##### TABLAS DE SIMBOLOS #####");
    for (Map.Entry<String, ArrayList<String[]>> entry : tablasDeSimbolos.entrySet()) {
        System.out.println("\n##### " + entry.getKey() + " #####");
        for (String[] symbol : entry.getValue()) {
            System.out.println("Tipo: " + symbol[0] + " ID: " + symbol[1] + " Tipo de dato: " + symbol[2]); 
        }
    }
}

//Metodo para imprimir el codigo intermedio
public void imprimirCodigoIntermedio() {
    System.out.println("\n##### CODIGO INTERMEDIO #####");
    for (String code : intermediateCode) {
        System.out.println(code);
    }
}


//Metodo para obtener un symbolo
public String[] getSymbol(List<String[]> tabla, String id) {
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[1].equals(id)) {
            return symbol; // Devuelve el símbolo que coincide con el ID.
        }
    }
    return null; // Si no se encuentra el símbolo, devuelve null o maneja el caso según tus necesidades.
}

//Metodo para obtener los parametros de una funcion

     

:};


init with {: :};
scan with {: return lexer.next_token(); :};



/** TERMINALES **/
terminal PLUS, MINUS, TIMES, LPAREN, RPAREN, DIVIDE, MODULE, POWER, INCREMENT, DECREMENT, ASSIGN, ENDLINE, EQUALS, DIFFERENT, GREATER,
 LESS, GREATEREQUAL, LESSEQUAL, AND, OR, NOT, BLOCKSTART, BLOCKEND, COMMA, SEPARATOR, IF, ELSE, IDENTIFIER, RETURN, BREAK, FOR, IN,
 RANGE, WHILE, SWITCH, CASE, DOTS, DEFAULT, READ, READSYMBOL, PRINT, PRINTSYMBOL, INTEGERTYPE, FLOATTYPE, BOOLEANTYPE, CHARTYPE,
 STRINGTYPE, BOOLEAN, INTEGER, FLOAT, CHAR, STRING;

terminal ERROR_RECOVERY;


/** NO TERMINALES **/
non terminal type;

non terminal  function, functions, program, parameter, parameters, expression, statement, statements, if_struct, if_else_struct, while_struct,
              while_else_struct, for_range_struct, decl, assignment, decl_and_assignment, readData, printData, callFunction, case_statement,
              case_statements, default_statement, switch_struct,aritmeticExpression, relationalExpression, logicalExpression, literal, aritmeticOp,
              relationalOp, logicalOp, operand, functionIdentifier,varIdentifier, return_statement, break_statement, callFunction_statement,
              error_recovery,errors, globalVariable, globalVariables,sendParameters;


//PRECEDENCIA
precedence left OR;
precedence left AND;
precedence left EQUALS, DIFFERENT, GREATER, LESS, GREATEREQUAL, LESSEQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULE, POWER;
precedence right NOT;

start with program;


type ::= INTEGERTYPE {:RESULT = "int"; :}
       | FLOATTYPE {:RESULT = "float"; :}
       | BOOLEANTYPE {:RESULT = "bool"; :}
       | CHARTYPE {:RESULT = "char"; :}
       | STRINGTYPE {:RESULT = "string"; :};

literal ::= INTEGER:n {: RESULT = n+":int"; :}  
          | FLOAT:n {: RESULT = n+":float"; :} 
          | CHAR:n {: RESULT = n+":char"; :}  
          | STRING:n {: RESULT = n+":string"; :} 
          | BOOLEAN:n {: RESULT = n+":bool"; :};

aritmeticOp ::= PLUS | MINUS |  TIMES |  DIVIDE |  MODULE | POWER;

operand ::= literal:n    {:
                            RESULT = n;    
                        :} 

        |   IDENTIFIER:id {:
                            ArrayList<String[]> tabla = tablasDeSimbolos.get(currentHash);
                            String[] symbol = getSymbol(tabla, id.toString());
                            String tipoId = symbol[2];
                            System.out.println("tipo encontado para id: "+id+" es: "+tipoId);            
                            RESULT = id+":"+tipoId;
                        :}          
        |   callFunction;
           
relationalOp ::= EQUALS | DIFFERENT | GREATER | LESS | GREATEREQUAL | LESSEQUAL;
logicalOp ::= AND | OR;


/** EXPRESSIONS **/

// EXPRESIONES ARITMETICAS
aritmeticExpression ::= operand:n 
{:

    RESULT = n; 

:}
| MINUS literal:n 

{: 

    if (!String.valueOf(n).endsWith("int") && !String.valueOf(n).endsWith("float")) {
        System.out.println("Error semantico en la linea x: Operacion aritmetica no valida");
    }
    RESULT = "-"+n; 
    //cod 3d
    intermediateCode.add("\nt"+currentTemp++ +" =- "+n);
 

:}
| IDENTIFIER:id INCREMENT 
{:
    ArrayList<String[]> tabla = tablasDeSimbolos.get(currentHash);
    String[] symbol = getSymbol(tabla, id.toString());
    String tipoId = symbol[2];

    System.out.println("tipo encontado para id: "+id+" es: "+tipoId);
    if (!tipoId.equals("int"))
    System.out.println("Error semantico en la linea x: No se permite el uso de incremento en variables de tipo: "+tipoId);  
    RESULT = id+":"+tipoId;
    //cod 3d
    intermediateCode.add("\nt"+currentTemp++ +" =+ "+id);
:}
| IDENTIFIER:id DECREMENT 
{:

    ArrayList<String[]> tabla = tablasDeSimbolos.get(currentHash);
    String[] symbol = getSymbol(tabla, id.toString());
    String tipoId = symbol[2];

    System.out.println("tipo encontado para id: "+id+" es: "+tipoId);
    if (!tipoId.equals("int")){
        System.out.println("Error semantico en la linea x: No se permite el uso de decremento en variables de tipo: "+tipoId);  
    }
    RESULT = id+":"+tipoId;
    //cod 3d
    intermediateCode.add("\nt"+currentTemp++ +" =- "+id);

:};


aritmeticExpression ::= aritmeticExpression aritmeticOp aritmeticExpression;
aritmeticExpression ::= LPAREN aritmeticExpression RPAREN;

//EXPRESIONES RELACIONALES
relationalExpression ::= aritmeticExpression relationalOp aritmeticExpression;

// EXPRESIONES LOGICAS
logicalExpression ::= relationalExpression;//| operand;
logicalExpression ::= logicalExpression logicalOp logicalExpression;
logicalExpression ::= LPAREN logicalExpression RPAREN;
logicalExpression ::= NOT logicalExpression;

expression ::= aritmeticExpression:e
{:
    RESULT = e; //Enviar solo el tipo de dato
:} 

| logicalExpression:e
{:
    RESULT = e; //Enviar solo el tipo de dato
:};


/** CONTROL STRUCTURES **/

if_struct ::= IF LPAREN expression RPAREN BLOCKSTART statements BLOCKEND;

if_else_struct ::= if_struct ELSE BLOCKSTART statements BLOCKEND;

while_struct ::= WHILE LPAREN logicalExpression RPAREN BLOCKSTART statements BLOCKEND;

while_else_struct ::= while_struct ELSE BLOCKSTART statements BLOCKEND;

for_range_struct ::= FOR SEPARATOR IDENTIFIER SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression COMMA
                     aritmeticExpression COMMA aritmeticExpression RPAREN BLOCKSTART statements BLOCKEND;
for_range_struct ::= FOR SEPARATOR IDENTIFIER SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression COMMA
                     aritmeticExpression RPAREN BLOCKSTART statements BLOCKEND;
for_range_struct ::= FOR SEPARATOR IDENTIFIER SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression RPAREN BLOCKSTART statements BLOCKEND;

default_statement ::= DEFAULT DOTS statements;

case_statement ::= CASE SEPARATOR literal DOTS statements;

case_statements ::= case_statement;
case_statements ::= case_statements case_statement;

switch_struct ::= SWITCH LPAREN expression RPAREN BLOCKSTART case_statements BLOCKEND;
switch_struct ::= SWITCH LPAREN expression RPAREN BLOCKSTART case_statements default_statement BLOCKEND;
switch_struct ::= SWITCH LPAREN expression RPAREN BLOCKSTART default_statement BLOCKEND;


/** STATEMENTS **/

varIdentifier ::= type:t SEPARATOR IDENTIFIER:idVar 
{:
    //Agregar id a la tabla de simbolos
    String[] symbol = new String[3];
    symbol[0] = "Variable";
    symbol[1] = idVar.toString();
    symbol[2] = t.toString();

    tablasDeSimbolos.get(currentHash).add(symbol);
:}; 

decl ::= varIdentifier ENDLINE;

assignment ::= IDENTIFIER ASSIGN expression ENDLINE;

decl_and_assignment ::= varIdentifier ASSIGN  expression ENDLINE;

readData ::= READ READSYMBOL IDENTIFIER ENDLINE;

printData ::= PRINT PRINTSYMBOL expression ENDLINE;


sendParameters ::= expression:e 
{:
   
:};

sendParameters ::= sendParameters COMMA expression;

callFunction ::= IDENTIFIER:id LPAREN sendParameters:actualParams  RPAREN 
{: 
/*
    if (tablasDeSimbolos.containsKey(id.toString())) { //Verificar si la funcion existe
        ArrayList<String[]> tabla = tablasDeSimbolos.get(id.toString()); //Obtener la tabla de simbolos de la funcion
        String[] titulo = tabla.get(0); //Obtener el titulo de la tabla de simbolos de la funcion

        if (titulo[0].equals("main")) { //Verificar si la funcion es main
            System.out.println("Error semantico en la linea x: La función main no recibe parametros");
        }

        // Verificar si los parametros enviados coinciden con los parametros de la funcion
        for ()

      
    }else{
        System.out.println("Error semantico en la linea x: La funcion "+id.toString()+" no existe");
    }
   */       

:};

callFunction ::= IDENTIFIER LPAREN RPAREN;

callFunction_statement ::= callFunction ENDLINE;

return_statement ::= RETURN SEPARATOR expression ENDLINE;
return_statement ::= RETURN ENDLINE;

break_statement ::= BREAK ENDLINE;

statement ::=   decl | assignment | decl_and_assignment | readData | printData | return_statement | break_statement |
                callFunction_statement | if_struct | if_else_struct| while_struct | while_else_struct | for_range_struct
                | switch_struct;

statements ::= statement;
statements ::= statements statement;


/** PARAMETERS **/

parameter ::= type:t SEPARATOR IDENTIFIER:idParam 
{:

    ArrayList<String[]> tabla = tablasDeSimbolos.get(currentHash);

     // Verificar si el parámetro ya existe en la tabla
    boolean exists = false;
    /*
    for (String[] symbol : tabla) {
        if (symbol[0].equals("Parametro") && symbol[1].equals(idParamString)) {
            System.out.println("Error semantico en la linea x: El parametro "+idParamString+" ya existe");
            exists = true;
            break;
        }
    }*/

    if (!exists) {
        // Agregar el parámetro solo si no existe en la tabla
        String[] symbol = new String[3];
        symbol[0] = "Parametro";
        symbol[1] = idParam.toString();
        symbol[2] = t.toString();
        tabla.add(symbol);

        tablasDeSimbolos.put(currentHash, tabla);
    }

    //Agregar id a la tabla de simbolos
    String[] symbol = new String[3];
    symbol[0] = "Parametro";
    symbol[1] = idParam.toString();
    symbol[2] = t.toString();

    tablasDeSimbolos.get(currentHash).add(symbol);
   
:};

parameters ::= parameter;
parameters ::= parameters COMMA parameter;
parameters ::= errors; //  parmetros no válidos


/** FUNCTIONS **/

functionIdentifier ::= type:t SEPARATOR IDENTIFIER :idFunc 
{:

// Crear tabla de simbolos para la funcion

    String tipoTabla = "main";
    if (idFunc.toString().equals("main")){
    tipoTabla = "Tipo: main: "+t.toString();
    }
    else{
    tipoTabla = "Tipo: funcion: "+t.toString();
    }

    ArrayList<String[]> tabla = new ArrayList<>();
    String[] titulo = new String[1];
    titulo[0] = tipoTabla;
    tabla.add(titulo);
    tablasDeSimbolos.put(currentHash, tabla);

   //cod 3d
   currentTemp = 1;
    intermediateCode.add("\n\nbegin_func_ "+idFunc.toString()+":");

:}; 

function ::= functionIdentifier LPAREN parameters RPAREN BLOCKSTART statements BLOCKEND
           | functionIdentifier LPAREN  RPAREN BLOCKSTART statements BLOCKEND;

functions ::= function;
functions ::= functions function;
functions ::= errors; // Error cuando hay algo fuera de una funcion


globalVariable ::= decl | decl_and_assignment;
globalVariables ::= globalVariable;
globalVariables ::= globalVariables globalVariable;



/** PUNTO DE ENTRADA **/
program ::= globalVariables | functions
{:
   // imprimirTablaSimbolos();
:};

program ::= globalVariables functions  
{:
   // imprimirTablaSimbolos();
:};

error_recovery ::= ERROR_RECOVERY:err 
{:
    if (!errorDisplayed){
        System.out.println("EL ARCHIVO FUENTE NO PUEDE SER GENERADO POR LA GRAMÁTICA \n\nERRORS:\n ");
        errorDisplayed = true;
    } 
    System.out.println("[ERROR] Caracter Invalido: "+err);
                                        
:} |

IDENTIFIER: err 
{: 

    //MANEJO DE ERRORES
    if (!errorDisplayed){
        System.out.println("EL ARCHIVO FUENTE NO PUEDE SER GENERADO POR LA GRAMÁTICA \n\nERRORS:\n ");
        errorDisplayed = true;
    }   
    System.out.println("[ERROR] Statement Out of Place: "+err); 
                    
:} ; 

errors ::= error_recovery;
errors ::= errors error_recovery;