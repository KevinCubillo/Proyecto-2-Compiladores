package com.compiladores;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

parser code  {:

    //Connect to the lexer
    Lexer lexer;
    public Boolean errorDisplayed = false;
    Map<String, ArrayList<String[]>> tablasDeSimbolos = new HashMap<>();
    String currentHash = "";

    @SuppressWarnings("deprecation")
    public parser(Lexer lexer) {
        this.lexer = lexer;
        this.symbolFactory = new DefaultSymbolFactory();

        //Inicializar tabla de simbolos Global
        currentHash = "Tabla Global";
        ArrayList<String[]> tabla = new ArrayList<>();
        String[] tipo = new String[2];
        tipo[0] = "Variables";
        tipo[1] = "Globales";
        tabla.add(tipo);
        tablasDeSimbolos.put(currentHash, tabla);
    }


//Metodo para obtener un symbolo
public String[] getSymbol(List<String[]> tabla, String id) {
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[1].equals(id)) {
            return symbol; // Devuelve el símbolo que coincide con el ID.
        }
    }
    return null; // Si no se encuentra el símbolo, devuelve null o maneja el caso según tus necesidades.
}

//Metodo para buscar si existe un parametro
public boolean existParam(List<String[]> tabla, String id) {
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[0].equals("Param") && symbol[1].equals(id)) {
            return true; // si encontró el parametro
        }
    }
    return false; //  no encontró el parametro
}

//Metodo que devuelve los tipos de los parametros de una funcion
public ArrayList<String> getFuncParamsTypes(List<String[]> tabla) {
    ArrayList<String> paramsTypes = new ArrayList<>();
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[0].equals("Parametro")) {
            paramsTypes.add(symbol[2]);
        }
    }
    return paramsTypes;
}

 //Codigo intermedio
    //List<String> intermediateCode = new ArrayList<>();

    StringBuffer intermediateCode = new StringBuffer();
    int currentTemp = 1;
    int structs = 0;


public StringBuffer getIntermediateCode() {
    return  intermediateCode;
}

:};




init with {: :};
scan with {: return lexer.next_token(); :};



/** TERMINALES **/
terminal PLUS, MINUS, TIMES, LPAREN, RPAREN, DIVIDE, MODULE, POWER, INCREMENT, DECREMENT, ASSIGN, ENDLINE, EQUALS, DIFFERENT, GREATER,
 LESS, GREATEREQUAL, LESSEQUAL, AND, OR, NOT, BLOCKSTART, BLOCKEND, COMMA, SEPARATOR, IF, ELSE, IDENTIFIER, RETURN, BREAK, FOR, IN,
 RANGE, WHILE, SWITCH, CASE, DOTS, DEFAULT, READ, READSYMBOL, PRINT, PRINTSYMBOL, INTEGERTYPE, FLOATTYPE, BOOLEANTYPE, CHARTYPE,
 STRINGTYPE, BOOLEAN, INTEGER, FLOAT, CHAR, STRING;

terminal ERROR_RECOVERY;


/** NO TERMINALES **/
non terminal type;

non terminal  function, functions, program, parameter, parameters, expression, statement, statements, if_struct, if_else_struct, while_struct,
              while_else_struct, for_range_struct, decl, assignment, decl_and_assignment, readData, printData, callFunction, case_statement,
              case_statements, default_statement, switch_struct,aritmeticExpression, relationalExpression, logicalExpression, literal, aritmeticOp,
              relationalOp, logicalOp, operand, functionIdentifier,varIdentifier, return_statement, break_statement, callFunction_statement,
              error_recovery,errors, globalVariable, globalVariables,sendParameters;


//PRECEDENCIA
precedence left OR;
precedence left AND;
precedence left EQUALS, DIFFERENT, GREATER, LESS, GREATEREQUAL, LESSEQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULE, POWER;
precedence right NOT;
precedence left LPAREN; 

start with program;


type ::= INTEGERTYPE {:RESULT = "int"; :}
       | FLOATTYPE {:RESULT = "float"; :}
       | BOOLEANTYPE {:RESULT = "bool"; :}
       | CHARTYPE {:RESULT = "char"; :}
       | STRINGTYPE {:RESULT = "string"; :};

literal ::= INTEGER:n {: RESULT = n+":int"; :}  
          | FLOAT:n {: RESULT = n+":float"; :} 
          | CHAR:n {: RESULT = n+":char"; :}  
          | STRING:n {: RESULT = n+":string"; :} 
          | BOOLEAN:n {: RESULT = n+":bool"; :};

aritmeticOp ::= PLUS:plus {: RESULT = plus; :}
| MINUS:minus {: RESULT = minus; :}
| TIMES:times {: RESULT = times; :}
| DIVIDE:divide {: RESULT = divide; :}
| MODULE:module {: RESULT = module; :}
| POWER:power {: RESULT = power; :};

operand ::= literal:n    
{:
    String codigo = "t"+currentTemp++ +" = "+n.toString().split(":")[0];  
    RESULT = codigo;
   
:} 

| IDENTIFIER:id 
{:
    //code 3d
    String codigo = "t"+currentTemp++ +" = "+id.toString();
    RESULT = codigo;
                                                       
:} 

| callFunction:cf
{:
    RESULT = cf;

:};

            
relationalOp ::= EQUALS:eq {: RESULT = eq; :}  | DIFFERENT:dif {: RESULT = dif; :}  | GREATER:gr {: RESULT = gr; :} 
| LESS:less {: RESULT = less; :}  | GREATEREQUAL:gre {: RESULT = gre; :} | LESSEQUAL:leq {: RESULT = leq; :};

logicalOp ::= AND:and {: RESULT = and; :}  | OR:or {: RESULT = or; :} ;


/** EXPRESSIONS **/

// EXPRESIONES ARITMETICAS
aritmeticExpression ::= operand:n 
{:  
    
    RESULT = n; 

:}
| MINUS literal:n 

{: 
    //cod 3d
    String code = "t"+currentTemp++ + " = -"+n.toString().split(":")[0];
    RESULT = code;

:}

| IDENTIFIER:id INCREMENT 
{:
     //cod 3d 
    String tempId= "t"+currentTemp++;
    String tempPP1= "t"+currentTemp++;
    String tempPP2= "t"+currentTemp++;
    String codigo = tempId +" = "+ id + "\n" + tempPP1 +" = 1"+"\n"+tempPP2 +" = "+tempId+" + "+tempPP1+"\n"+id +" = "+tempPP2;
    RESULT = codigo;


:}

| IDENTIFIER:id DECREMENT 
{:

    //cod 3d 
    String tempId= "t"+currentTemp++;
    String tempPP1= "t"+currentTemp++;
    String tempPP2= "t"+currentTemp++;
    String codigo = tempId +" = "+ id + "\n" + tempPP1 +" = 1"+"\n"+tempPP2 +" = "+tempId+" - "+tempPP1+"\n"+id +" = "+tempPP2;
    RESULT = codigo;

:};


aritmeticExpression ::= aritmeticExpression:e1 aritmeticOp:op aritmeticExpression:e2
{:

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String codigo = e1.toString() + "\n" + e2.toString() + "\n" + "t"+ currentTemp++ +" = " + temporale1 + op + "t"+(currentTemp-1);

    RESULT = codigo;
  
:};

aritmeticExpression ::= LPAREN aritmeticExpression RPAREN;

//EXPRESIONES RELACIONALES
relationalExpression ::= aritmeticExpression:e1 relationalOp:op aritmeticExpression:e2
{:

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado
    String codigo = e1.toString() + "\n" + e2.toString() + "\n" + "t"+currentTemp++ +" = " + temporale1 + op + "t"+(currentTemp-2);

    RESULT = codigo;

:};

// EXPRESIONES LOGICAS
logicalExpression ::= relationalExpression:e1
{:

    RESULT = e1;

:};

logicalExpression ::= logicalExpression logicalOp logicalExpression;
logicalExpression ::= LPAREN logicalExpression RPAREN;
logicalExpression ::= NOT logicalExpression;

expression ::= aritmeticExpression:e
{:
    RESULT = e; 
:} 

| logicalExpression:e
{:
    RESULT = e; 
:};


/** CONTROL STRUCTURES **/

if_struct ::= IF LPAREN logicalExpression:e1 RPAREN BLOCKSTART statements:st BLOCKEND
{:

     //cod 3d

    String idFunc = currentHash;

    String[] lineas = e1.toString().split("\n");  // Divide la cadena en líneas
    String temporale1 = lineas[lineas.length - 1];
    temporale1 = temporale1.split(" = ")[0]; // Obtiene el último temporal generado


    //moverme a antes de la expresion logica
    String etiquetaPrincipal = idFunc+"_if_"+ ++structs+":\n";
    String operacionLogica = e1.toString();
    String saltoAfirmativo = "\nif " + temporale1 + " goto "+ idFunc + "_if_"+ structs + "_bloque";
    String saltoNegativo = "\ngoto "+ idFunc + "_if_"+ structs + "_bloque_end";
    String etiquetaBloque = "\n"+ idFunc + "_if_"+ structs + "_bloque:\n";

    //escribir todo lo de statements
    String statements = st.toString();

    String etiquetaBloqueEnd = "\n"+ idFunc + "_if_"+ structs + "_bloque_end:";

    RESULT = etiquetaPrincipal + operacionLogica + saltoAfirmativo + saltoNegativo + etiquetaBloque + statements + etiquetaBloqueEnd;


:};

if_else_struct ::= if_struct ELSE BLOCKSTART statements BLOCKEND;

while_struct ::= WHILE LPAREN logicalExpression RPAREN BLOCKSTART statements BLOCKEND;

while_else_struct ::= while_struct ELSE BLOCKSTART statements BLOCKEND;

for_range_struct ::= FOR SEPARATOR IDENTIFIER:id SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression:e1 COMMA
                     aritmeticExpression:e2 COMMA aritmeticExpression:e3 RPAREN BLOCKSTART statements BLOCKEND
{:


:}

| FOR SEPARATOR IDENTIFIER:id SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression:e1 COMMA
                     aritmeticExpression:e2 RPAREN BLOCKSTART statements BLOCKEND
{:


:}

| FOR SEPARATOR IDENTIFIER:id SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression:e1 RPAREN BLOCKSTART statements BLOCKEND
{:


:};

default_statement ::= DEFAULT DOTS statements;

case_statement ::= CASE SEPARATOR literal:lit DOTS statements
{:
  
    RESULT = lit;
:};

case_statements ::= case_statement:cs
{:
    
:};

case_statements ::= case_statements:css case_statement:cs
{:
    RESULT = css + "," + cs;

:};

switch_struct ::= SWITCH LPAREN expression:e1 RPAREN BLOCKSTART case_statements:types BLOCKEND
{:


:};

switch_struct ::= SWITCH LPAREN expression:e1 RPAREN BLOCKSTART case_statements:types default_statement BLOCKEND
{:


:};

switch_struct ::= SWITCH LPAREN expression RPAREN BLOCKSTART default_statement BLOCKEND;


/** STATEMENTS **/

varIdentifier ::= type:t SEPARATOR IDENTIFIER:idVar 
{:

    String code =  "data_"+t.toString()+" "+idVar.toString();
    RESULT = code;
  
:}; 

decl ::= varIdentifier:vi ENDLINE
{:

    RESULT = vi;

:};

assignment ::= IDENTIFIER:id ASSIGN expression:e1 ENDLINE
{:

    String code = e1.toString()+"\n"+id.toString()+" = "+"t"+(currentTemp-1);
    
    RESULT = code;  
       
:};

decl_and_assignment ::= varIdentifier:vi ASSIGN expression:e1 ENDLINE
{:
    String code = vi.toString()+"\n"+e1.toString()+"\n"+id.toString()+" = "+"t"+(currentTemp-1);
    RESULT = code;

:};

readData ::= READ READSYMBOL IDENTIFIER:id ENDLINE
{:

:};

printData ::= PRINT PRINTSYMBOL expression ENDLINE;


sendParameters ::= expression:e 
{:
 
:}

| sendParameters:params COMMA expression:e

{:
 
:};

callFunction ::= IDENTIFIER:id LPAREN sendParameters:actualParams  RPAREN 
{: 

 

:};

callFunction ::= IDENTIFIER:id LPAREN RPAREN
{:

  

:};

callFunction_statement ::= callFunction ENDLINE;

return_statement ::= RETURN SEPARATOR expression:e ENDLINE
{:


:}
| RETURN ENDLINE;

break_statement ::= BREAK ENDLINE;

statement ::=   decl:decl{: RESULT = decl; :} | assignment:assig {: RESULT = assig; :} | decl_and_assignment | readData | printData | return_statement | break_statement |
                callFunction_statement | if_struct:if_str {: RESULT = if_str; :} | if_else_struct| while_struct | while_else_struct | for_range_struct
                | switch_struct;

statements ::= statement:st 
{: 
    RESULT = st;
:};

statements ::= statements:sts statement:st
{:

    RESULT = sts + "\n" + st;
    
:};


/** PARAMETERS **/

parameter ::= type:t SEPARATOR IDENTIFIER:idParam 
{:


:};

parameters ::= parameter;
parameters ::= parameters COMMA parameter;
parameters ::= errors; //  parmetros no válidos


/** FUNCTIONS **/

functionIdentifier ::= type:t SEPARATOR IDENTIFIER :idFunc 
{:

 
    //  Definir el tipo de tabla
        String tipoTabla = "main";
        if (idFunc.toString().equals("main")){
        tipoTabla = "Tipo: main ";
        }
        else{
        tipoTabla = "Tipo: funcion ";
        }

    // Crear tabla de simbolos para la funcion
        currentHash = idFunc.toString();
        ArrayList<String[]> tabla = new ArrayList<>();
        String[] tipo = new String[2];
        tipo[0] = tipoTabla;
        tipo[1] = t.toString();
        tabla.add(tipo);
        tablasDeSimbolos.put(currentHash, tabla);

        //code 3d
        currentTemp = 1;
        String codigo = "\n\nbegin_func_"+idFunc.toString()+":\n";
        RESULT = codigo;

        
:}; 

function ::= functionIdentifier LPAREN parameters RPAREN BLOCKSTART statements BLOCKEND
| functionIdentifier:fi LPAREN  RPAREN BLOCKSTART statements:st BLOCKEND
           
{:

String code = fi.toString() + st.toString();
intermediateCode.append(code);
           
:};

functions ::= function;
functions ::= functions function;
functions ::= errors; // Error cuando hay algo fuera de una funcion


globalVariable ::= decl | decl_and_assignment;
globalVariables ::= globalVariable;
globalVariables ::= globalVariables globalVariable;


/** PUNTO DE ENTRADA **/
program ::= globalVariables | functions
{:

:};

program ::= globalVariables functions  
{:

:};

error_recovery ::= ERROR_RECOVERY:err 
{:
    if (!errorDisplayed){
        System.out.println("EL ARCHIVO FUENTE NO PUEDE SER GENERADO POR LA GRAMÁTICA \n\nERRORS:\n ");
        errorDisplayed = true;
    } 
    System.out.println("[ERROR] Caracter Invalido: "+err);
                                        
:} |

expression: err 
{: 

    //MANEJO DE ERRORES
    if (!errorDisplayed){
        System.out.println("EL ARCHIVO FUENTE NO PUEDE SER GENERADO POR LA GRAMÁTICA \n\nERRORS:\n ");
        errorDisplayed = true;
    }   
    System.out.println("[ERROR] Statement Out of Place: "+err); 
                    
:} ; 

errors ::= error_recovery;
errors ::= errors error_recovery;