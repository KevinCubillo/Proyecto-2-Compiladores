package com.compiladores;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


parser code  {:

    //Connect to the lexer
    Lexer lexer;
    public Boolean errorDisplayed = false;
    Map<String, ArrayList<String[]>> tablasDeSimbolos = new HashMap<>();
    String currentHash = "";

    @SuppressWarnings("deprecation")
    public parser(Lexer lexer) {
        this.lexer = lexer;
        this.symbolFactory = new DefaultSymbolFactory();

        //Inicializar tabla de simbolos Global
        currentHash = "Tabla Global";
        ArrayList<String[]> tabla = new ArrayList<>();
        String[] tipo = new String[2];
        tipo[0] = "Variables";
        tipo[1] = "Globales";
        tabla.add(tipo);
        tablasDeSimbolos.put(currentHash, tabla);
    }

//Metodo para imprimir la tabla de simbolos
public void imprimirTablaSimbolos() {
    System.out.println("\n##### TABLAS DE SIMBOLOS #####");
    for (Map.Entry<String, ArrayList<String[]>> entry : tablasDeSimbolos.entrySet()) {
        String tablaNombre = entry.getKey();
        System.out.println("\n##### " + tablaNombre + " #####");

        ArrayList<String[]> symbols = entry.getValue();

        // Imprimir el tipo de tabla
        System.out.println(symbols.get(0)[0]+" "+symbols.get(0)[1]);

        for (int i = 1; i < symbols.size(); i++) {   
            System.out.println(symbols.get(i)[0] + ", ID:" + symbols.get(i)[1] + ", Tipo:" + symbols.get(i)[2]); 
        }
    }
}

//Metodo para obtener un symbolo
public String[] getSymbol(List<String[]> tabla, String id) {
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[1].equals(id)) {
            return symbol; // Devuelve el símbolo que coincide con el ID.
        }
    }
    return null; // Si no se encuentra el símbolo, devuelve null o maneja el caso según tus necesidades.
}

//Metodo para buscar si existe un parametro
public boolean existParam(List<String[]> tabla, String id) {
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[0].equals("Param") && symbol[1].equals(id)) {
            return true; // si encontró el parametro
        }
    }
    return false; //  no encontró el parametro
}

//Metodo que devuelve los tipos de los parametros de una funcion
public ArrayList<String> getFuncParamsTypes(List<String[]> tabla) {
    ArrayList<String> paramsTypes = new ArrayList<>();
    for (int i = 1; i < tabla.size(); i++) {
        String[] symbol = tabla.get(i);
        if (symbol[0].equals("Parametro")) {
            paramsTypes.add(symbol[2]);
        }
    }
    return paramsTypes;
}

:};


init with {: :};
scan with {: return lexer.next_token(); :};



/** TERMINALES **/
terminal PLUS, MINUS, TIMES, LPAREN, RPAREN, DIVIDE, MODULE, POWER, INCREMENT, DECREMENT, ASSIGN, ENDLINE, EQUALS, DIFFERENT, GREATER,
 LESS, GREATEREQUAL, LESSEQUAL, AND, OR, NOT, BLOCKSTART, BLOCKEND, COMMA, SEPARATOR, IF, ELSE, IDENTIFIER, RETURN, BREAK, FOR, IN,
 RANGE, WHILE, SWITCH, CASE, DOTS, DEFAULT, READ, READSYMBOL, PRINT, PRINTSYMBOL, INTEGERTYPE, FLOATTYPE, BOOLEANTYPE, CHARTYPE,
 STRINGTYPE, BOOLEAN, INTEGER, FLOAT, CHAR, STRING;

terminal ERROR_RECOVERY;


/** NO TERMINALES **/
non terminal type;

non terminal  function, functions, program, parameter, parameters, expression, statement, statements, if_struct, if_else_struct, while_struct,
              while_else_struct, for_range_struct, decl, assignment, decl_and_assignment, readData, printData, callFunction, case_statement,
              case_statements, default_statement, switch_struct,aritmeticExpression, relationalExpression, logicalExpression, literal, aritmeticOp,
              relationalOp, logicalOp, operand, functionIdentifier,varIdentifier, return_statement, break_statement, callFunction_statement,
              error_recovery,errors, globalVariable, globalVariables,sendParameters;


//PRECEDENCIA
precedence left OR;
precedence left AND;
precedence left EQUALS, DIFFERENT, GREATER, LESS, GREATEREQUAL, LESSEQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULE, POWER;
precedence right NOT;

start with program;


type ::= INTEGERTYPE {:RESULT = "int"; :}
       | FLOATTYPE {:RESULT = "float"; :}
       | BOOLEANTYPE {:RESULT = "bool"; :}
       | CHARTYPE {:RESULT = "char"; :}
       | STRINGTYPE {:RESULT = "string"; :};

literal ::= INTEGER:n {: RESULT = n+":int"; :}  
          | FLOAT:n {: RESULT = n+":float"; :} 
          | CHAR:n {: RESULT = n+":char"; :}  
          | STRING:n {: RESULT = n+":string"; :} 
          | BOOLEAN:n {: RESULT = n+":bool"; :};

aritmeticOp ::= PLUS | MINUS |  TIMES |  DIVIDE |  MODULE | POWER;

operand ::= literal:n    
{:
    RESULT = n;    
:} 

| IDENTIFIER:id 
{:

    ArrayList<String[]> tabla = tablasDeSimbolos.get(currentHash);
    String[] symbol = getSymbol(tabla, id.toString());
    if (symbol == null) {
        System.out.println("Error semantico en la linea x: "+id.toString()+" no ha sido declarado");
    }else{
        String tipoId = symbol[2];
        RESULT = id+":"+tipoId;     
    }
                                                       
:} 

| callFunction;
           
relationalOp ::= EQUALS | DIFFERENT | GREATER | LESS | GREATEREQUAL | LESSEQUAL;
logicalOp ::= AND | OR;


/** EXPRESSIONS **/

// EXPRESIONES ARITMETICAS
aritmeticExpression ::= operand:n 
{:

    RESULT = n; 

:}
| MINUS literal:n 

{: 

    if (!String.valueOf(n).endsWith("int") && !String.valueOf(n).endsWith("float")) {
        System.out.println("Error semantico en la linea x: Operacion aritmetica no valida");
    }
    RESULT = "-"+n; 

:}
| IDENTIFIER:id INCREMENT 
{:
    ArrayList<String[]> tabla = tablasDeSimbolos.get(currentHash);
    String[] symbol = getSymbol(tabla, id.toString());
    String tipoId = symbol[2];

    System.out.println("tipo encontado para id: "+id+" es: "+tipoId);
    if (!tipoId.equals("int"))
    System.out.println("Error semantico en la linea x: No se permite el uso de incremento en variables de tipo: "+tipoId);  
    RESULT = id+":"+tipoId;
:}
| IDENTIFIER:id DECREMENT 
{:

    ArrayList<String[]> tabla = tablasDeSimbolos.get(currentHash);
    String[] symbol = getSymbol(tabla, id.toString());
    String tipoId = symbol[2];

    System.out.println("tipo encontado para id: "+id+" es: "+tipoId);
    if (!tipoId.equals("int")){
        System.out.println("Error semantico en la linea x: No se permite el uso de decremento en variables de tipo: "+tipoId);  
    }
    RESULT = id+":"+tipoId;

:};


aritmeticExpression ::= aritmeticExpression aritmeticOp aritmeticExpression;
aritmeticExpression ::= LPAREN aritmeticExpression RPAREN;

//EXPRESIONES RELACIONALES
relationalExpression ::= aritmeticExpression relationalOp aritmeticExpression;

// EXPRESIONES LOGICAS
logicalExpression ::= relationalExpression;//| operand;
logicalExpression ::= logicalExpression logicalOp logicalExpression;
logicalExpression ::= LPAREN logicalExpression RPAREN;
logicalExpression ::= NOT logicalExpression;

expression ::= aritmeticExpression:e
{:
    RESULT = e; //Enviar solo el tipo de dato
:} 

| logicalExpression:e
{:
    RESULT = e; //Enviar solo el tipo de dato
:};


/** CONTROL STRUCTURES **/

if_struct ::= IF LPAREN expression RPAREN BLOCKSTART statements BLOCKEND;

if_else_struct ::= if_struct ELSE BLOCKSTART statements BLOCKEND;

while_struct ::= WHILE LPAREN logicalExpression RPAREN BLOCKSTART statements BLOCKEND;

while_else_struct ::= while_struct ELSE BLOCKSTART statements BLOCKEND;

for_range_struct ::= FOR SEPARATOR IDENTIFIER SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression COMMA
                     aritmeticExpression COMMA aritmeticExpression RPAREN BLOCKSTART statements BLOCKEND;
for_range_struct ::= FOR SEPARATOR IDENTIFIER SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression COMMA
                     aritmeticExpression RPAREN BLOCKSTART statements BLOCKEND;
for_range_struct ::= FOR SEPARATOR IDENTIFIER SEPARATOR IN SEPARATOR RANGE LPAREN aritmeticExpression RPAREN BLOCKSTART statements BLOCKEND;

default_statement ::= DEFAULT DOTS statements;

case_statement ::= CASE SEPARATOR literal DOTS statements;

case_statements ::= case_statement;
case_statements ::= case_statements case_statement;

switch_struct ::= SWITCH LPAREN expression RPAREN BLOCKSTART case_statements BLOCKEND;
switch_struct ::= SWITCH LPAREN expression RPAREN BLOCKSTART case_statements default_statement BLOCKEND;
switch_struct ::= SWITCH LPAREN expression RPAREN BLOCKSTART default_statement BLOCKEND;


/** STATEMENTS **/

varIdentifier ::= type:t SEPARATOR IDENTIFIER:idVar 
{:

    // Verificar si la variable ya existe en el ámbito actual
    
    String varName = idVar.toString();
    String varType = t.toString();
    List<String[]> tabla = tablasDeSimbolos.get(currentHash);
    boolean variableExist = false;

    // Busca en la tabla de símbolos si la variable ya existe en el ámbito actual
    for (String[] symbol : tabla) {
        if (symbol[0].equals("Variable") && symbol[1].equals(varName)) {
            // La variable ya existe en el ámbito actual
            variableExist = true;
            break;
        }
    }
    if (variableExist) {
        System.out.println("Error: La variable '" + varName + "' ya ha sido declarada en este ámbito.");

    } else {
        // Agregar la variable a la tabla de símbolos
        String[] symbol = new String[3];
        symbol[0] = "Variable";
        symbol[1] = varName;
        symbol[2] = varType;
        tabla.add(symbol);
    }
    
:}; 

decl ::= varIdentifier ENDLINE;

assignment ::= IDENTIFIER ASSIGN expression ENDLINE;

decl_and_assignment ::= varIdentifier ASSIGN  expression ENDLINE;

readData ::= READ READSYMBOL IDENTIFIER ENDLINE;

printData ::= PRINT PRINTSYMBOL expression ENDLINE;


sendParameters ::= expression:e 
{:
    RESULT = e;
:}

| sendParameters:params COMMA expression:e

{:
    RESULT = params + "," + e;
:};

callFunction ::= IDENTIFIER:id LPAREN sendParameters:actualParams  RPAREN 
{: 

    if (tablasDeSimbolos.containsKey(id.toString())) { //Verificar si la funcion existe
        ArrayList<String[]> tabla = tablasDeSimbolos.get(id.toString()); //Obtener la tabla de simbolos de la funcion
        String[] titulo = tabla.get(0); //Obtener el titulo de la tabla de simbolos de la funcion

     
        // Verificar si los parametros enviados coinciden con los parametros de la funcion
        ArrayList<String> funcParamstypes = getFuncParamsTypes(tabla);
        String[] sendParams = actualParams.toString().split(",");

    
        if (funcParamstypes.size() != sendParams.length) {
            System.out.println("Error semantico en la linea x: La cantidad de parametros enviados no coincide con la cantidad de parametros de la funcion: "+ id.toString());
        } else {
            for (int i = 0; i < funcParamstypes.size(); i++) {
                if (sendParams[i].equals("null")) {
                    break;   // No se muestra el error ya que en operand se mostró al validar el id 
                }
                String paramType1 = funcParamstypes.get(i); // Tipo de dato del parametro de la funcion
                String paramType2 = sendParams[i].split(":")[1]; // Tipo de dato del parametro enviado

                if (!paramType1.equals(paramType2)) { // Verificar si los tipos de datos coinciden
                    System.out.println("Error semantico en la linea x: Se esperaba un parametro de tipo "+paramType1+" y se recibio uno de tipo "+paramType2);
                }   
            }
        }
       
        

      
    }else{
        System.out.println("Error semantico en la linea x: La funcion "+id.toString()+" no existe");
    }
        

:};

callFunction ::= IDENTIFIER LPAREN RPAREN;

callFunction_statement ::= callFunction ENDLINE;

return_statement ::= RETURN SEPARATOR expression ENDLINE;
return_statement ::= RETURN ENDLINE;

break_statement ::= BREAK ENDLINE;

statement ::=   decl | assignment | decl_and_assignment | readData | printData | return_statement | break_statement |
                callFunction_statement | if_struct | if_else_struct| while_struct | while_else_struct | for_range_struct
                | switch_struct;

statements ::= statement;
statements ::= statements statement;


/** PARAMETERS **/

parameter ::= type:t SEPARATOR IDENTIFIER:idParam 
{:

    ArrayList<String[]> tabla = tablasDeSimbolos.get(currentHash);

     // Verificar si el parámetro ya existe en la tabla
    if (existParam(tabla, idParam.toString())) {
        System.out.println("Error semantico en la linea x: Nombre de parametro duplicado: " + idParam.toString());
    } else{

        // Agregar el parámetro en la tabla
        String[] symbol = new String[3];
        symbol[0] = "Parametro";
        symbol[1] = idParam.toString();
        symbol[2] = t.toString();
        tabla.add(symbol);
    }

:};

parameters ::= parameter;
parameters ::= parameters COMMA parameter;
parameters ::= errors; //  parmetros no válidos


/** FUNCTIONS **/

functionIdentifier ::= type:t SEPARATOR IDENTIFIER :idFunc 
{:

// Crear tabla de simbolos para la funcion

    String tipoTabla = "main";
    if (idFunc.toString().equals("main")){
    tipoTabla = "Tipo: main "+t.toString();
    }
    else{
    tipoTabla = "Tipo: funcion "+t.toString();
    }

    currentHash = idFunc.toString();
    ArrayList<String[]> tabla = new ArrayList<>();
    String[] tipo = new String[2];
    tipo[0] = tipoTabla;
    tipo[1] = t.toString();
    tabla.add(tipo);
    tablasDeSimbolos.put(currentHash, tabla);
   
:}; 

function ::= functionIdentifier LPAREN parameters RPAREN BLOCKSTART statements BLOCKEND
           | functionIdentifier LPAREN  RPAREN BLOCKSTART statements BLOCKEND;

functions ::= function;
functions ::= functions function;
functions ::= errors; // Error cuando hay algo fuera de una funcion


globalVariable ::= decl | decl_and_assignment;
globalVariables ::= globalVariable;
globalVariables ::= globalVariables globalVariable;


/** PUNTO DE ENTRADA **/
program ::= globalVariables | functions
{:
    imprimirTablaSimbolos();
:};

program ::= globalVariables functions  
{:
    imprimirTablaSimbolos();
:};

error_recovery ::= ERROR_RECOVERY:err 
{:
    if (!errorDisplayed){
        System.out.println("EL ARCHIVO FUENTE NO PUEDE SER GENERADO POR LA GRAMÁTICA \n\nERRORS:\n ");
        errorDisplayed = true;
    } 
    System.out.println("[ERROR] Caracter Invalido: "+err);
                                        
:} |

IDENTIFIER: err 
{: 

    //MANEJO DE ERRORES
    if (!errorDisplayed){
        System.out.println("EL ARCHIVO FUENTE NO PUEDE SER GENERADO POR LA GRAMÁTICA \n\nERRORS:\n ");
        errorDisplayed = true;
    }   
    System.out.println("[ERROR] Statement Out of Place: "+err); 
                    
:} ; 

errors ::= error_recovery;
errors ::= errors error_recovery;